//I ORIGINALLY wanted to do this with Tone.js.  Tone makes what Im doing here VERY easy.  E.g., looping and swing are built in.  BUT I had performance issues with transport on mobile. (My metronome was occasionally pushing notes a little late when the CPU got busy.) Mobile use was critical to me because I want to practice away from my computer. So I decided to learn how to use the Web Audio API itself.  In hindsight, I suspect I was making some n00b mistake with Tone, but it was a good excuse to go deeper and learn things! YAY LEARNING

// Todos
// [ ] fix recent audio-breaking error in android: "An AudioContext in a cross origin iframe must be created or resumed from a user gesture to enable audio output." Guess I gotta start this guy off with a BEGIN button or something.  That or dont run this app through the codepen iframe.  
// [ ] fix autofocus of input for spinners (this creates annoying effect on mobile)

// GLOBAL OPTIONS-----------------------------------
// Let's set up some options.  Most will be manipulatable with the UI.
var _quarterOn = false; // Is the quarter note turned on?
var _eighthOn = false; // Eighth notes?
var _sixteenthOn = false; // Sixteenth notes?
var _startTempo = 120; // Tempo to start?
var _eighthSwing = 0; // Where the second eighth note in each beat is placed 0 is precisely two eight notes, 1 is dotted eight sixteenth. 67 is an exact triplet swing
var _sixteenthSwing = 0; // Where the sixteenth notes in each beat is placed.  Analogous to eighthSwing 
var _randMute = 0; // The percentage chance that the metronome will "drop" a beat and be silent (this helps with test you to see if you are keeping time or relying on the metronome
var _numBeats = 4; // Number beats per measure
var _volume = 50; // Volume of clicks (%)
var _volumeMult = 10; //This will multiply the gain because PJ wanted it louder.

// AUDIO CONTEXT-----------------------------------
// Web Audio needs an audio "context" object.  This is where ALL the audio magic happens.
var _context;
try {
  // There are a few prefixes we might need to use, let's find the right one
  window.AudioContext = window.AudioContext || window.webkitAudioContext;
  // Make the context
  _context = new AudioContext();
} catch (e) {
  // If it doesn't work, alert error
  alert('No Webkit Audio API!');
}

// LOAD SOUNDS (BUFFERS)-----------------------------------
// The code below creates an object that handles loading the sounds we'll need into memory (into an array "buffers").  
// Transcribed from http://www.html5rocks.com/en/tutorials/webaudio/intro/js/buffer-loader.js
// For more, check out this tutorial: http://www.html5rocks.com/en/tutorials/webaudio/intro/
//    Parameters: 
//      context - audio context
//      urls - an array listing the urls to load
//      onload - a function to execute when done, our buffer list will be passed to it
bufferLoader = function (context, urls, onload) {
  this.context = context;
  this.urls = urls;
  this.onload = onload;
  this.buffers = new Array();
  this.nLoaded = 0;
}
bufferLoader.prototype.loadBuffer = function(url, index) {
  // Load buffer asynchronously 
  var request = new XMLHttpRequest();
  request.open("GET", url, true);
  request.responseType = "arraybuffer";
  
  var loader = this;
  request.onload = function () {
    // Asynchronously decode the audio file data in request.response
    loader.context.decodeAudioData (
      request.response,
      function(buffer) { // On success
        if (!buffer) {
          alert('error decoding file data: '+url);
          return;
        }
        loader.buffers[index] = buffer;
        if (++loader.nLoaded == loader.urls.length) { // If we've loaded them all
          loader.onload(loader.buffers); // Call our onload function
        }
      },
      function(error) { // Decode error handling
        console.error('decodeAudioData error',error);
      }
    );
  }
  // Request error handling
  request.onerror = function() { 
    alert('bufferLoader: XHR error');
  }
  // Drum roll...
  request.send();
}
// This is the method to call to load the sounds.  It calls the rest sequentially.
bufferLoader.prototype.load = function() {
  for (var i = 0; i < this.urls.length; ++i)
    this.loadBuffer(this.urls[i], i);
}
  
try {  
  // Using the bufferLoader object we made above, let's load our clave sounds
  var urls = [
    'https://s3-us-west-2.amazonaws.com/s.cdpn.io/385326/clave_low.wav',
    'https://s3-us-west-2.amazonaws.com/s.cdpn.io/385326/clave_med.wav',
    'https://s3-us-west-2.amazonaws.com/s.cdpn.io/385326/clave_high.wav' 
    // Thanks to Matt Greenberg for inspiring me to mess with Web Audio. http://codepen.io/mattgreenberg/pens/popular/
    // Also I stole your clave sound, muhfuggah! COME GET ME.
    // _high and _med sound were generated by speeding up _low with Audacity
  ];
  bufferLoader = new bufferLoader(_context,urls,allSoundsLoaded);
  bufferLoader.load();
} catch (e) {
  // If it didn't work, send an error message.
  alert('Error loading sounds.');
}

//HANDLE SOUND PLAYING-----------------------------------
//  Function to play sounds
//    Parameters: 
//      buffer - audio buffer of desired sound
//      time - when to play
//      gain - volume to play sound 0 to 1
//      context - the audio context with the destination we'll use
//    Returns:
//      source - an audio source so we can reference this later
function playSound(buffer, time, gain, context) {
  // Set up audio source
  var source = context.createBufferSource();
  source.buffer = buffer;
  // Create gain node
  var gainNode = context.createGain();
  // Connect nodes
  source.connect(gainNode);
  gainNode.connect(context.destination);
  // Set gain
  gainNode.gain.value = gain;
  // Play the sound
  source.start(time);
  return source
}

//LOOPER OBJECT-----------------------------------
//  Function to schedule sounds to play for a dynamic loop (specified by a function).
//  Concept based heavily off of: http://www.html5rocks.com/en/tutorials/audio/scheduling/ (but I coded it way worse :P ).
//  The idea is to frequently fire scheduler functions to schedule audio events.  These schedulers have a window they are responsible for.  
//  The window is first cleared of all audio events previously scheduled (in case the loop has changed), then new audio events are scheduled. 
//  This allows the loop to change on the fly and protects the timing from any delays in computation.
//  My choices for the window are explained below under "Scheduler options"
//    Parameters: 
//      loopFunction - a function that returns a loop array [{buffer:,beat:,gain:},{buffer:,beat:,gain:},,...]
//      tempo - in bpm
//      numBeats - how many beats in a loop
//      context - the audio context
//    Methods:
//      start(), stop(), restart(), updateLoop(), clearScheduled(), scheduler()
function looper(loopFunction,tempo,numBeats,context) {
  // Grab parameters
  this.tempo = tempo;
  this.context = context
  this.numBeats = numBeats;
  this.loopFunction = loopFunction;

  // Scheduler options
  this.schedulerInterval = .05; // How often scheduler fires
  this.schedulerWindowStart = .1; // Beginning of scheduler's window (time from fire) -- any notes within this window will be scheduled/rescheduled
  // Why not have this be 0?  Good question.  We want a slight delay here because if it were 0, it is possible that this scheduler would be responsible 
  // for a sound that would need to be played BEFORE ITS CODE IS DONE.  So by the time the sound is scheduled, it is late.  Sources scheduled to play at 
  // a time before now fire now.  The result is a late note. Yuck.
  this.schedulerWindowEnd = 1.2; // End of scheduler's window (time from fire) -- any notes within this window will be scheduled/rescheduled
  // Why so goddman long a window?  If we are setting this up and clearing it every time, doesn't that suck?
  // Ya.  It does.  Window must be greater than 1s in order to have chrome continue to play metronome when tab out of focus (only 1/s setTimeout permitted).
  // There's probably a better way to do this -- perhaps change the window when out of focus?  Next update.

  // Declare some empty variables we'll need later
  this.startTime = null;
  this.schedulerTimeOut = null;
  this.scheduled = [];    
  this.beatDur = null;
  this.loopDur = null;
  this.loop = [];

  // Grab onto our identity for in methods
  var self = this;
  
  // Start the loop
  this.start = function (startTime) {
    self.startTime = startTime || self.context.currentTime; // Default to right now, if not specified
    // Calculate loop and beat durations
    self.beatDur = 60 / this.tempo; //the length of a beat at this tempo
    self.loopDur = this.numBeats * self.beatDur;
    // Update loop and start the scheduler madness
    self.updateLoop();
    self.scheduler();
  }

  // Stop the loop
  this.stop = function () {
    // Halt the scheduler madness
    if(self.schedulerTimeOut) {
      clearTimeout(self.schedulerTimeOut)
    }
    // Clear all scheduled notes
    self.clearScheduled();
  }

  // Restart the loop (this is necessary when changing tempo)
  this.restart = function() {
    self.stop();
    self.start();
  }

  // Stop all scheduled sounds (scheduled after time clearAfter) and clean up sources array
  this.clearScheduled = function (clearAfter) {
    if (self.scheduled) {
      var newScheduled = []; // This will house everything we want to keep
      var now = self.context.currentTime;
      var clearAfter = clearAfter || now; // Default to clearing everything

      // Loop through all scheduled (faster than for loop)
      i = 0; while(i < self.scheduled.length){ 

        // Learn about this source's scheduling
        // var bufferDur = self.scheduled[i].source.buffer.duration; < might need this for next update
        var sourceStart = self.scheduled[i].time;

        // Stop sounds that start after clearAfter
        if ( sourceStart > clearAfter ) { 
          self.scheduled[i].source.stop();
        } else if ( sourceStart > now ) { // If they don't start after clearAfter (else) and have yet to start....
          newScheduled.push(self.scheduled[i]); // ...add them to our newScheduled array (which will replace scheduled at the end)
        }
        i++;
      }
    }
    // The old switcheroo
    self.scheduled = newScheduled;
  }

  // Update the loop array with the loopFunction (this lets our loop behave dynamically)
  this.updateLoop = function () {
    self.loop = self.loopFunction();
  }

  // Schedule next sounds in loop to play
  this.scheduler = function () {

    // Immediately schedule the next scheduler
    self.schedulerTimeOut = window.setTimeout(self.scheduler, self.schedulerInterval*1000);

    // Update the loop
    self.updateLoop();

    // When am I?
    var now = self.context.currentTime;
    var timeSinceStart = now - self.startTime;
    var currentLoopNum = Math.floor( timeSinceStart / self.loopDur );
    var currentLoopStart = self.startTime + ( currentLoopNum * self.loopDur );

    // Calculate the window we are responsible for scheduling within
    var windowStart = now + self.schedulerWindowStart;
    var windowEnd = now + self.schedulerWindowEnd;
    var windowDur = windowEnd-windowStart;

    // Erase any prior scheduling
    self.clearScheduled(windowStart);

    // Schedule the sounds that fall in this time interval
    j = 0; while(j <= Math.ceil(windowDur/self.loopDur)) { // We'll go through the loop as many times as it can fit in our window rounded up (+1 again for safety)
      i = 0; while(i < self.loop.length) { // Loop through all sounds in loop -- this is faster than for loop (probably splitting hairs here....)
        var soundTime = (self.loop[i].beat * self.beatDur) + (self.loopDur * j) + currentLoopStart; // When should this sound (in the current loop iteration) be played?
        if (soundTime > windowStart && soundTime <= windowEnd ) { // If this event time is within the window of this scheduler
          self.scheduled.push( {source: playSound( self.loop[i].buffer, soundTime, self.loop[i].gain, self.context ), time: soundTime} ); // Play sound and add source to sources array
        }
        i++;
      }
      j++;
    }

  }
}

//LOOP -----------------------------------
metroLoop = function() {
  //this function generates the loop that will be played by the looper
  var loop = [];

  if(_quarterOn) { //if quarter notes are on...
    loop.push( //add quarter notes
      { buffer: _claveLowBuffer, beat: 0, gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, //mute at random based on _randMute (this guy returns T or F read as 1 or 0)
      { buffer: _claveLowBuffer, beat: 1, gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, //also apply volume setting
      { buffer: _claveLowBuffer, beat: 2, gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveLowBuffer, beat: 3, gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }
    )
  }
  if(_eighthOn) {//ditto for eighths
    loop.push(
      { buffer: _claveMedBuffer, beat: 0+(1/2)+(_eighthSwing/100/4), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, //note the equation for swing
      { buffer: _claveMedBuffer, beat: 1+(1/2)+(_eighthSwing/100/4), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveMedBuffer, beat: 2+(1/2)+(_eighthSwing/100/4), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveMedBuffer, beat: 3+(1/2)+(_eighthSwing/100/4), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }  
    )
  }  
  if(_sixteenthOn) {//ditto for sixteenths
    loop.push(
      { buffer: _claveHighBuffer, beat: 0+(1/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveHighBuffer, beat: 0+(3/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveHighBuffer, beat: 1+(1/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveHighBuffer, beat: 1+(3/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveHighBuffer, beat: 2+(1/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveHighBuffer, beat: 2+(3/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveHighBuffer, beat: 3+(1/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult }, 
      { buffer: _claveHighBuffer, beat: 3+(3/4)+(_sixteenthSwing/100/8), gain: (Math.random()>_randMute/100)*(_volume/100)*_volumeMult } 
    )
  }
  return loop;
}

function initUI() {

  // UI BUTTONS-----------------------------------

  // Quarter Note Button
  $('#quarter').on('click', function() {
    playSound(_claveLowBuffer,0,0,_context); // Play muted sound
    // Why?  Good question.
    // For iOS audio will not play unless a sound is first triggered by a user interaction like a click event.
    // A muted sound on the first thing a user clicks to get audio will do the trick.
    _quarterOn = !_quarterOn;
    $(this).removeClass('on');
    $(this).addClass(_quarterOn ? 'on' : '');
  });

  // Eighth Note Button
  $('#eighth').on('click', function() {
    playSound(_claveLowBuffer,0,0,_context); // Play muted sound -- this activates audio on iOS
    _eighthOn = !_eighthOn;
    $(this).removeClass('on');
    $(this).addClass(_eighthOn ? 'on' : '');
  });

  // Sixteenth Note Button
  $('#sixteenth').on('click', function() {
    playSound(_claveLowBuffer,0,0,_context); // Play muted sound -- this activates audio on iOS
    _sixteenthOn = !_sixteenthOn;
    $(this).removeClass('on');
    $(this).addClass(_sixteenthOn ? 'on' : '');
  });

  // UI SLIDERS / SPINNERS ----------------------------------- (Thanks JQuery UI!!)

  // Base settings -- Almost all of our sliders have these options.
  var defaultOptions = {
    change: userChangedASetting,
    slide: userChangedASetting,
    spin: userChangedASetting,
    range: 'min',
    max: 100,
    step: 1,
    min: 0
  }
  // Create those sliders / spinners
  $('.eighthSwing.slider, .sixteenthSwing.slider, .randMute.slider').slider(defaultOptions);
  $('.eighthSwing.spinner, .sixteenthSwing.spinner, .randMute.spinner').spinner(defaultOptions);
  
  // Tempo needs different settings
  var tempoOptions = jQuery.extend(true, {}, defaultOptions); // Clone the base options
  tempoOptions.min = 10; // Add our changes
  tempoOptions.max = 260;
  $('.tempo.slider').slider(tempoOptions); // Make UI Elements
  $('.tempo.spinner').spinner(tempoOptions);
  // Ditto for volume slider ....
  var volumeOptions = jQuery.extend(true, {}, defaultOptions);
  volumeOptions.orientation = 'vertical';
  $('.volume.slider').slider(volumeOptions);

  // Custom HTML for Spinner Buttons (I want it myyyyyyy way)
  // Thanks http://stackoverflow.com/questions/14405970/override-html-result-jqueryui-spinner
   $('.spinner').parent().find(".ui-spinner-button.ui-spinner-up").empty().append("<span class='arrow'>&#x25B2</span>").click(function(e) {
     e.preventDefault();
   }); //Up Button
   $('.spinner').parent().find(".ui-spinner-button.ui-spinner-down").empty().append("<span class='arrow'>&#x25BC;</span>"); //Down Button

  // MORE INFO LINKS-----------------------------------
  // Elaborate on what some of these settings are when ? is clicked
  // Open and close info accordians
  $('.info').velocity("slideUp", { duration: 0 }); // Start closed
  $('.toggle-info').on('click',function(e){ // When we clicked
    e.preventDefault();
    $info = $(this).closest('.has-info').find('.info'); // Find the info div we are responsible for
    if($(this).hasClass('on')){
      $(this).removeClass('on');
      $info.velocity("slideUp", { duration: 250 }); // Velocity.js is a good solution for smoothly getting this accordian effect.  (Thanks Matt Soria! http://codepen.io/poopsplat/pens/public/)
    }else{
      $(this).addClass('on');
      $info.velocity("slideDown", { duration: 250 });
    }
  });

}

// When a user interacts with a UI element, change the setting where it matters
function userChangedASetting(event, ui) {
  
  if (event.originalEvent) { // This is important.  Without it, we go to infinite loop town as updateUI will trigger a change event and that will retrigger userChangedASetting and so on
    // Which UI element did the user change?
    if($(event.target).hasClass(myClass='tempo')) { // In this case, it was tempo (save 'tempo' to myClass)
        var newValue = !(typeof ui.value === 'undefined') ? ui.value : $('.'+myClass+'.spinner').spinner('value'); //This is obnoxious.  
        //When this function is called for slider's slide event or spinner's spin event the value is stored in ui.value 
        //Jquery spinners on their CHANGE event pass an empty ui object.  Maybe for a good reason?  Anyway, in this case, we grab it manually.
        _metroLooper.tempo = newValue; // Change the tempo in it's canonical location
        _metroLooper.restart(); // You have to restart the metronome when changing tempo otherwise it'll break.
     } else if ($(event.target).hasClass(myClass='eighthSwing')) { //Ditto for the next few....
        var newValue = !(typeof ui.value === 'undefined') ? ui.value : $('.'+myClass+'.spinner').spinner('value');
        _eighthSwing = newValue;
    }else if ($(event.target).hasClass(myClass='sixteenthSwing')) {
        var newValue = !(typeof ui.value === 'undefined') ? ui.value : $('.'+myClass+'.spinner').spinner('value');
        _sixteenthSwing = newValue;
    }else if ($(event.target).hasClass(myClass='randMute')) {
        var newValue = !(typeof ui.value === 'undefined') ? ui.value : $('.'+myClass+'.spinner').spinner('value');
        _randMute = newValue;
    }else if ($(event.target).hasClass(myClass='volume')) { 
        var newValue = !(typeof ui.value === 'undefined') ? ui.value : $('.'+myClass+'.spinner').spinner('value');
        _volume = newValue;
    }
    updateUI(); // Update the UI to reflect the change 
    // Why?  because these settings are represented by both sliders AND spinners–we can't have them holding different values.
  }
}

// Update all UI elements to reflect the most up to date value of their respective settings
function updateUI() {
  // The values the UI represents
  var values = [
    _metroLooper.tempo,
    _eighthSwing,
    _sixteenthSwing,
    _randMute,
    _volume
  ];
  // The CSS class held by the UI items that represent those values
  var classes = [
    '.tempo', 
    '.eighthSwing',
    '.sixteenthSwing',
    '.randMute',
    '.volume'
  ];
  // Loop through each class and update the associates spinner and slider (if they exist)
  for(i=0;i<classes.length;i++) {
    var $slider = $(classes[i]+'.slider')
    if ($slider.length) $slider.slider('value',values[i]);
    var $spinner = $(classes[i]+'.spinner')
    if ($spinner.length) $spinner.spinner('value',values[i]);
  }

  // Update the swing-visualizer
  $('.ee').css('top',((_sixteenthSwing/100)*12.5+25)+'%');
  $('.and').css('top',((_eighthSwing/100)*25+50)+'%');
  $('.uh').css('top',((_sixteenthSwing/100)*12.5+75)+'%');

  //  Update italian tempo markings
  var tempi = [  //Our list
    {name: 'Slow af',     min: 10, max: 25},
    {name: 'Grave',       min: 25, max: 45},
    {name: 'Lento',       min: 45, max: 60},
    {name: 'Largo',       min: 40, max: 60},
    {name: 'Larghetto',   min: 60, max: 66},
    {name: 'Adagio',      min: 66, max: 76},
    {name: 'Andante',     min: 76, max: 108},
    {name: 'Moderato',    min: 108, max: 120},
    {name: 'Allegretto',  min: 112, max: 120},
    {name: 'Allegro',     min: 120, max: 168},
    {name: 'Vivace',      min: 168, max: 176},
    {name: 'Presto',      min: 168, max: 200},
    {name: 'Prestissimo', min: 200, max: 250},
    {name: 'Impractical', min: 250, max: 301}
  ];

  $('.italian').empty(); // Start fresh
  for(i=0;i<tempi.length;i++){ //Loop thru, append what applies
    if ( _metroLooper.tempo >= tempi[i].min && _metroLooper.tempo < tempi[i].max ) {
      $('.italian').append('<li>'+tempi[i].name+'</li>')
    }
  }
}

// The function triggered when BufferLoader has loaded all sounds.  (It passes us the buffers.)
function allSoundsLoaded(buffers) {
  _claveLowBuffer = buffers[0]; // Let's give these nice names and make them globally available.
  _claveMedBuffer = buffers[1];
  _claveHighBuffer = buffers[2];

  // Init the looper and start her going
  _metroLooper = new looper(metroLoop,_startTempo,_numBeats,_context); // Make and start our metronome loop!!
  _metroLooper.start();

  //Build
  initUI();

  // Add initial values to the UI
  updateUI();

  // Clear loading screen
  $('.loading').addClass('loaded');
}

// TODO ---------------------------------------------------------
// [ ] Remove autofocus for JQuery UI spinners on click of arrows. (Very annoying on mobile because on some platforms it pulls up the keyboard and hence changes the screen size and hence the size of everything.  So if you're trying to tap the arrow repeatedly, you can't. The second tap of the arrow misses. Ugh.)